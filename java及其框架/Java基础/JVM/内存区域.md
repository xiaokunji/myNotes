[toc]



# 1. 大纲

![img](https://gitee.com/xiaokunji/my-images/raw/master/myMD/20210712002935.png)



1、根据Java虚拟机规范，Java虚拟机所管理的内存包括方法区、虚拟机栈、本地方法栈、堆、程序计数器等。

2、我们通常认为JVM中运行时数据存储包括堆和栈。这里所提到的栈其实指的是虚拟机栈，或者说是虚拟栈中的局部变量表。

3、栈中存放一些基本类型的变量数据（int/short/long/byte/float/double/Boolean/char）和对象引用。

4、堆中主要存放对象，即通过new关键字创建的对象。

5、数组引用变量是存放在栈内存中，数组元素是存放在堆内存中。



hotspot jdk8中移除了永久代以后的内存结构

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313171623705-2036052608.jpg)

[JVM结构及堆的划分 - 光何 - 博客园 (cnblogs.com)](https://www.cnblogs.com/guanghe/p/10524314.html)

# 2. 方法区(元空间/永久代) 怎么回收对象?

《Java虚拟机规范》 中提到过可以不要求虚拟机在方法区中实现垃圾收集， 事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）  

方法区的垃圾收集主要回收两部分内容： **废弃的常量和不再使用的类型**  

**回收废弃常量**与回收Java堆中的对象非常类似。 举个常量池中字面量回收的例子， 假如一个字符串“java”曾经进入常量池中， 但是当前系统又没有任何一个字符串对象的值是“java”， 换句话说， 已经没有任何字符串对象引用常量池中的“java”常量， 且虚拟机中也没有其他地方引用这个字面量。 如果在这时发生内存回收， 而且垃圾收集器判断确有必要的话， 这个“java”常量就将会被系统清理出常量池。 常量池中其他类（接口） 、 方法、 字段的符号引用也与此类似  

**判定一个类型是否属于“不再被使用的类”的条件需要同时满足下面三个条件：**

- 该类所有的实例都已经被回收， 也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收， 这个条件除非是经过精心设计的可替换类加载器的场景， 如OSGi、 JSP的重加载等， 否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方法  

Java虚拟机被允许对满足上述三个条件的无用类进行回收， 这里说的仅仅是“被允许”， 而并不是和对象一样， 没有引用了就必然会回收  ,关于是否要对类型进行回收  , HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制  

在大量使用反射、 动态代理、 CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁<u>自定义类加载器</u>的场景中， 通常都需要Java虚拟机具备类型卸载的能力， 以保证不会对方法区造成过大的内存压力。  



# 3. 堆的分代

Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM的内存分代策略。

![img](https://img2018.cnblogs.com/blog/955092/201903/955092-20190313165427522-1253660306.jpg)

　Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念（JDK1.8之后为metaspace替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。

## 3.1 新生代（Young Generation）

　　新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。
　　**HotSpot将新生代划分为三块，一块较大的Eden（伊甸）空间和两块较小的Survivor（幸存者）空间，默认比例为8：1：1**。划分的目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
　　GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，要么移到老年代要么复制到To survivor区

> 年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。

接着， From Survivor区和To Survivor区会交换它们的角色，<u>也就是说新的To Survivor区就是上次GC清空的From Survivor区</u>，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。

## 3.2 老年代（Old Generationn）

　　在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。

这里会发生Full GC , 产生STW(stop the world)

[什么时候会触发Full GC（建议收藏） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/266257353)

## 3.3 永久代（Permanent Generationn）

　　永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。

[JVM结构及堆的划分 - 光何 - 博客园 (cnblogs.com)](https://www.cnblogs.com/guanghe/p/10524314.html)







