[toc]



# 1. volatile

## 1.1 volatile的内存语义

在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：

- 保证变量的**内存可见性**
- 禁止volatile变量与普通变量**重排序**（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）

> 这两个功能都是通过内存屏障实现的



```java
public class VolatileExample {
    int a = 0;
    volatile boolean flag = false;

    public void writer() {
        a = 1; // step 1
        flag = true; // step 2
    }

    public void reader() {
        if (flag) { // step 3
            System.out.println(a); // step 4
        }
    }
}
```

在这段代码里，我们使用`volatile`关键字修饰了一个`boolean`类型的变量`flag`。

所谓内存可见性，指的是当一个线程对`volatile`修饰的变量进行**写操作**（比如step 2）时，**JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存**；当一个线程对`volatile`修饰的变量进行**读操作**（比如step 3）时，**JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。**

> 在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。 所以上面的代码是线程安全的
>
> **单纯的赋值操作是原子性的**。

![img](http://concurrent.redspider.group/article/02/imgs/volatile%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

而如果`flag`变量**没有**用`volatile`修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值`a = 0，flag = false`。

> **工作内存改了值后, 主内存是怎么通知到其他工作内存该值已被修改了?**
>
> 答: 基于MESI协议, 缓存一致性协议(MESI只是其中一种)
>
> | 状态         | 描述                                                         |
> | ------------ | ------------------------------------------------------------ |
> | M(Modified)  | 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 |
> | E(Exclusive) | 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。 |
> | S(Shared)    | 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。 |
> | I(Invalid)   | 这行数据无效。                                               |
>
> 简单来说: cpu为每个变量都记录了状态(MESI四个状态),并通过总线嗅探机制变更每个工作线程中的对应变量的状态,不过这些都是cpu做的,不是JMM做的 
>
> **嗅探机制工作原理**：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。
>
> 注意：基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。(synchronize就没有总线风暴)
>
> 总线风暴:需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值, 
>
> [volatile 关键字，你真的理解吗？_Star's Tech Blog-CSDN博客_总线嗅探机制](https://blog.csdn.net/oschina_41790905/article/details/105951643)
>
> [从volatile关键字到总线风暴_瞎折腾的小码农的博客-CSDN博客](https://blog.csdn.net/qq_35015148/article/details/110210926)
>
> [缓存一致性协议（MESI） - 一念永恒乐 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ynyhl/p/12119690.html)



## 1.2 内存屏障

> 在linux中也有内存屏障,用的是写屏障 , 它保证了 修改数据和更新指针 之前的线程安全
>
> [Java中的内存屏障是什么 - xyyyn - 博客园 (cnblogs.com)](https://www.cnblogs.com/xyyyn/p/14000875.html)
>
> 以下只描述jdk1.8中的内存屏障

硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：

1. 阻止屏障两侧的指令重排序；
2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。

> 注意这里的缓存主要指的是CPU缓存，如L1，L2等

编译器在**生成字节码时**，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个**比较保守的JMM内存屏障插入策略**，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：

- 在每个volatile写操作前插入一个StoreStore屏障；
- 在每个volatile写操作后插入一个StoreLoad屏障；
- 在每个volatile读操作后插入一个LoadLoad屏障；
- 在每个volatile读操作后再插入一个LoadStore屏障。

![image](http://concurrent.redspider.group/article/02/imgs/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png)



> 再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作
>
> 1. LoadLoad：禁止读和读的重排序
> 2. StoreStore：禁止写与写的重排序
> 3. LoadStore：禁止读和写的重排序
> 4. StoreLoad：禁止写和读的重排序 , 它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

[Java中的内存屏障是什么_月月鸟的博客-CSDN博客_java 内存屏障](https://blog.csdn.net/u013301084/article/details/109473996)

对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：

> 第一个volatile读;
>
> LoadLoad屏障；
>
> 第二个volatile读；
>
> LoadStore屏障
>
> 总之,屏障能少就少,毕竟叠加屏障时,有些屏障就是多余的了
>
> [JMM——volatile与内存屏障_此岸花开-CSDN博客_jmm内存屏障](https://blog.csdn.net/hqq2023623/article/details/51013468)



**为什么volatile读前面没有屏障?**

答: 按理来说volatile的读写前后都需要加屏障, 但是volatile读前没有加

因为JMM认为读比写的概率要高,所以在volatile写后面加屏障次数就会少,性能更好

> [从汇编看Volatile的内存屏障 - SegmentFault 思否](https://segmentfault.com/a/1190000014315651)
>
> 更多思考 
>
> [java并发编程(二)-volatile写操作前为什么不加LoadStore屏障_公众号:大臭-CSDN博客_loadload屏障](https://blog.csdn.net/ly262173911/article/details/106063924)



>  JDK8开始，Java在Unsafe类中提供了三个内存屏障函数。
>
> ```java
> public final class Unsafe{
> 	***
> 
> 	public native void loadFence();
> 	public native void storeFence();
> 	public native void fullFence();
> 
> 	***
> }
> ```
>
> 在JDK9中对JDK定义的三种内存屏障与理论层面划分的四类内存屏障之间的对应进行了说明:
>
> - loadFence = LoadLoad+LoadStore
> - storeFence = StoreStore+LoadStore
> - fullFence = StoreStore+LoadStore+StoreLoad
>
> <p style="color:red">由于不同的CPU架构不同，重排序的策略不同，所提供的内存屏障也有差异。???<p>
>
> [Java中的内存屏障是什么 - xyyyn - 博客园 (cnblogs.com)](https://www.cnblogs.com/xyyyn/p/14000875.html)



# 2. final

## 2.1 final关键字的知识点

1. final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值(引用不可改变)。
2. 本地变量必须在声明时赋值。 因为没有初始化的过程
3. 接口中声明的所有变量本身是final的。类似于匿名类
4. 在匿名类中所有变量都必须是final变量。java中的String类和Integer类都是final类型的。
5. final方法不能被重写, final类不能被继承 , final方法调用时使用的是invokespecial指令。
6. final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
7. final方法在编译阶段绑定，称为静态绑定(static binding)。
8. 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。

**final方法的好处:**

1. 提高了性能，JVM在常量池中会缓存final变量
2. final变量在多线程中并发安全，无需额外的同步开销
3. final方法是静态编译的，提高了调用速度
4. **final类创建的对象是只可读的，在多线程可以安全共享**

[Java中static、final、static final的区别（转） - EasonJim - 博客园 (cnblogs.com)](https://www.cnblogs.com/EasonJim/p/7841990.html)

[深入理解final关键字 - 简书 (jianshu.com)](https://www.jianshu.com/p/067b6c89875a)



## 2.2 内存屏障

**对于 final 域，编译器和处理器要遵守两个重排序规则：**

1. 在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。(加了一个storestore屏障)

2. 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。(加了一个LoadLoad 屏障), 仅针对处理器

   > 就是说 用 对象的引用,和使用对象中的值 这两个操作不能重排序, 先读对象引用再读final域
   >
   > 本来这两种操作是存在间接依赖的,大部分处理器都不会重排序,但是有小部分处理仍会重排序(比如 alpha 处理器)

> 总结, 从构造函数修改了final域,是能保证线程"安全"的, 构造函数的执行和赋值不能重排序; 构造函数中的final在初始化未完成前,是不可见的

[深入理解final关键字 - 简书 (jianshu.com)](https://www.jianshu.com/p/067b6c89875a)

[深入理解Java内存模型（六）——final-InfoQ](https://www.infoq.cn/article/java-memory-model-6/)



## 2.3 案例

`LocalDateTime` 等时间类就是用final来保证的线程安全,包括它的格式化类

它整个类都是final的,每次操作`LocalDateTime`对象都是返回一个新的对象,当然也运用了final对构造函数的一个禁止重排序规则

[高并发之——SimpleDateFormat类的线程安全问题和解决方案_冰河的专栏-CSDN博客](https://blog.csdn.net/l1028386804/article/details/104397090)



#  3. synchronized

## 3.1 初识

`synchronized` 的作用主要有三：

- （1）、**原子性**：**所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**被`synchronized`修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。
- （2）、**可见性**：**可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。 **synchronized对一个类或对象加锁，这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。
- （3）、**有序性**：**有序性值程序执行的顺序按照代码先后执行。** synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。

[synchronized详解 - 三分恶 - 博客园 (cnblogs.com)](https://www.cnblogs.com/three-fighter/p/14396208.html)



首先需要明确的一点是：**Java多线程的锁都是基于对象的**，Java中的每一个对象都可以作为一个锁。

还有一点需要注意的是，我们常听到的**类锁**其实也是对象锁。

Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。

[9 synchronized与锁 · 深入浅出Java多线程 (redspider.group)](http://concurrent.redspider.group/article/02/9.html)



## 3.2  锁原理

**Synchronized主要有三种用法**：

- （1）、**修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

  ```java
  synchronized void method() {
    //业务代码
  }
  ```

- （2）、**修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ *static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份*）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

```java
synchronized void staic method() {
  //业务代码
}
```

- （3）、**修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

```java
synchronized(this) {
  //业务代码
}
```

**简单总结一下**：

`synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。

`synchronized` 关键字加到实例方法上是给对象实例上锁。



```java
// ① 关键字在实例方法上，锁为当前实例 
public synchronized void instanceLock() {
    // code
}
// ② 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    synchronized (this) {
        // code
    }
}

// ③ 关键字在静态方法上，锁为当前Class对象
public static synchronized void classLock() {
    // code
}
//④ 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    synchronized (this.getClass()) {
        // code
    }
}

//⑤ 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    Object o = new Object();
    synchronized (o) {
        // code
    }
}
```

> 从效果上来看
>
> ①和② 是等价的, 实例方法是被**new出来的对象**使用,所以synchronize修饰在方法上和锁定this(当前使用这个方法的人,就是new出来的对象嘛)是一样的.
>
> ④和⑤是等价的, static方法由类调用,所以④和⑤是一样的,这时锁住的对象是**class对象**
>
> [synchronized - 八锁问题及扩展_江南烟雨却痴缠丶-CSDN博客](https://blog.csdn.net/qq_40885085/article/details/110099014)

> 我们这里介绍一下“临界区”的概念。所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果`synchronized`关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。



### 3.2.1  synchronized 同步语句块原理

```java
public class SynchronizedDemo {
	public void method() {
		synchronized (this) {
			System.out.println("synchronized 代码块");
		}
	}
}
```



`javap -c -s -v -l SynchronizedDemo.class` 查看汇编代码

![](https://gitee.com/sanfene/picgo/raw/master/image-20210210160804090.png)

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置， `monitorexit` 指令则指明同步代码块的结束位置。**

当执行 `monitorenter` 指令时，线程试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权。

> 为什么会有两次monitorexit???
>
> 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 `ObjectMonitor`对象。
>
> 另外，**`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。**

在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

###  3.2.2  synchronized 修饰方法原理

```java
public class SynchronizedDemo2 {
	public synchronized void method() {
		System.out.println("synchronized 方法");
	}
}
```

汇编之后

![](https://gitee.com/xiaokunji/my-images/raw/master/myMD/20210922001319.png)

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。



**简单总结一下**：

`synchronized` **同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令**，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的**方法**并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实**是 `ACC_SYNCHRONIZED` 标识**，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**