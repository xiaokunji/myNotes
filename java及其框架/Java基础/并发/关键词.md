[toc]



# 1. volatile

## 1.1 volatile的内存语义

在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：

- 保证变量的**内存可见性**
- 禁止volatile变量与普通变量**重排序**（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）

> 这两个功能都是通过内存屏障实现的



```java
public class VolatileExample {
    int a = 0;
    volatile boolean flag = false;

    public void writer() {
        a = 1; // step 1
        flag = true; // step 2
    }

    public void reader() {
        if (flag) { // step 3
            System.out.println(a); // step 4
        }
    }
}
```

在这段代码里，我们使用`volatile`关键字修饰了一个`boolean`类型的变量`flag`。

所谓内存可见性，指的是当一个线程对`volatile`修饰的变量进行**写操作**（比如step 2）时，**JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存**；当一个线程对`volatile`修饰的变量进行**读操作**（比如step 3）时，**JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。**

> 在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。 所以上面的代码是线程安全的
>
> **单纯的赋值操作是原子性的**。

![img](http://concurrent.redspider.group/article/02/imgs/volatile%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

而如果`flag`变量**没有**用`volatile`修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值`a = 0，flag = false`。

> **工作内存改了值后, 主内存是怎么通知到其他工作内存该值已被修改了?**
>
> 答: 基于MESI协议, 缓存一致性协议(MESI只是其中一种)
>
> | 状态         | 描述                                                         |
> | ------------ | ------------------------------------------------------------ |
> | M(Modified)  | 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 |
> | E(Exclusive) | 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。 |
> | S(Shared)    | 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。 |
> | I(Invalid)   | 这行数据无效。                                               |
>
> 简单来说: cpu为每个变量都记录了状态(MESI四个状态),并通过总线嗅探机制变更每个工作线程中的对应变量的状态,不过这些都是cpu做的,不是JMM做的 
>
> **嗅探机制工作原理**：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。
>
> 注意：基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。(synchronize就没有总线风暴)
>
> 总线风暴:需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值, 
>
> [volatile 关键字，你真的理解吗？_Star's Tech Blog-CSDN博客_总线嗅探机制](https://blog.csdn.net/oschina_41790905/article/details/105951643)
>
> [从volatile关键字到总线风暴_瞎折腾的小码农的博客-CSDN博客](https://blog.csdn.net/qq_35015148/article/details/110210926)
>
> [缓存一致性协议（MESI） - 一念永恒乐 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ynyhl/p/12119690.html)



## 1.2 内存屏障

> 在linux中也有内存屏障,用的是写屏障 , 它保证了 修改数据和更新指针 之前的线程安全
>
> [Java中的内存屏障是什么 - xyyyn - 博客园 (cnblogs.com)](https://www.cnblogs.com/xyyyn/p/14000875.html)
>
> 以下只描述jdk1.8中的内存屏障

硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：

1. 阻止屏障两侧的指令重排序；
2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。

> 注意这里的缓存主要指的是CPU缓存，如L1，L2等

编译器在**生成字节码时**，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个**比较保守的JMM内存屏障插入策略**，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：

- 在每个volatile写操作前插入一个StoreStore屏障；
- 在每个volatile写操作后插入一个StoreLoad屏障；
- 在每个volatile读操作后插入一个LoadLoad屏障；
- 在每个volatile读操作后再插入一个LoadStore屏障。

![image](http://concurrent.redspider.group/article/02/imgs/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png)



> 再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作
>
> 1. LoadLoad：禁止读和读的重排序
> 2. StoreStore：禁止写与写的重排序
> 3. LoadStore：禁止读和写的重排序
> 4. StoreLoad：禁止写和读的重排序 , 它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

[Java中的内存屏障是什么_月月鸟的博客-CSDN博客_java 内存屏障](https://blog.csdn.net/u013301084/article/details/109473996)

对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：

> 第一个volatile读;
>
> LoadLoad屏障；
>
> 第二个volatile读；
>
> LoadStore屏障
>
> 总之,屏障能少就少,毕竟叠加屏障时,有些屏障就是多余的了
>
> [JMM——volatile与内存屏障_此岸花开-CSDN博客_jmm内存屏障](https://blog.csdn.net/hqq2023623/article/details/51013468)



**为什么volatile读前面没有屏障?**

答: 按理来说volatile的读写前后都需要加屏障, 但是volatile读前没有加

因为JMM认为读比写的概率要高,所以在volatile写后面加屏障次数就会少,性能更好

> [从汇编看Volatile的内存屏障 - SegmentFault 思否](https://segmentfault.com/a/1190000014315651)
>
> 更多思考 
>
> [java并发编程(二)-volatile写操作前为什么不加LoadStore屏障_公众号:大臭-CSDN博客_loadload屏障](https://blog.csdn.net/ly262173911/article/details/106063924)



>  JDK8开始，Java在Unsafe类中提供了三个内存屏障函数。
>
> ```java
> public final class Unsafe{
> 	***
> 
> 	public native void loadFence();
> 	public native void storeFence();
> 	public native void fullFence();
> 
> 	***
> }
> ```
>
> 在JDK9中对JDK定义的三种内存屏障与理论层面划分的四类内存屏障之间的对应进行了说明:
>
> - loadFence = LoadLoad+LoadStore
> - storeFence = StoreStore+LoadStore
> - fullFence = StoreStore+LoadStore+StoreLoad
>
> <p style="color:red">由于不同的CPU架构不同，重排序的策略不同，所提供的内存屏障也有差异。???<p>
>
> [Java中的内存屏障是什么 - xyyyn - 博客园 (cnblogs.com)](https://www.cnblogs.com/xyyyn/p/14000875.html)



# 2. final

## 2.1 final关键字的知识点

1. final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值(引用不可改变)。
2. 本地变量必须在声明时赋值。 因为没有初始化的过程
3. 接口中声明的所有变量本身是final的。类似于匿名类
4. 在匿名类中所有变量都必须是final变量。java中的String类和Integer类都是final类型的。
5. final方法不能被重写, final类不能被继承 , final方法调用时使用的是invokespecial指令。
6. final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
7. final方法在编译阶段绑定，称为静态绑定(static binding)。
8. 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。

**final方法的好处:**

1. 提高了性能，JVM在常量池中会缓存final变量
2. final变量在多线程中并发安全，无需额外的同步开销
3. final方法是静态编译的，提高了调用速度
4. **final类创建的对象是只可读的，在多线程可以安全共享**

[Java中static、final、static final的区别（转） - EasonJim - 博客园 (cnblogs.com)](https://www.cnblogs.com/EasonJim/p/7841990.html)

[深入理解final关键字 - 简书 (jianshu.com)](https://www.jianshu.com/p/067b6c89875a)



## 2.2 内存屏障

**对于 final 域，编译器和处理器要遵守两个重排序规则：**

1. 在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。(加了一个storestore屏障)

2. 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。(加了一个LoadLoad 屏障), 仅针对处理器

   > 就是说 用 对象的引用,和使用对象中的值 这两个操作不能重排序, 先读对象引用再读final域
   >
   > 本来这两种操作是存在间接依赖的,大部分处理器都不会重排序,但是有小部分处理仍会重排序(比如 alpha 处理器)

> 总结, 从构造函数修改了final域,是能保证线程"安全"的, 构造函数的执行和赋值不能重排序; 构造函数中的final在初始化未完成前,是不可见的

[深入理解final关键字 - 简书 (jianshu.com)](https://www.jianshu.com/p/067b6c89875a)

[深入理解Java内存模型（六）——final-InfoQ](https://www.infoq.cn/article/java-memory-model-6/)



## 2.3 案例

`LocalDateTime` 等时间类就是用final来保证的线程安全,包括它的格式化类

它整个类都是final的,每次操作`LocalDateTime`对象都是返回一个新的对象,当然也运用了final对构造函数的一个禁止重排序规则

[高并发之——SimpleDateFormat类的线程安全问题和解决方案_冰河的专栏-CSDN博客](https://blog.csdn.net/l1028386804/article/details/104397090)



#  3. synchronized





