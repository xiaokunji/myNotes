[toc]

# 1. 前言

线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。

为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。

> “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。
>
> 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：
>
> 1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
> 2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
> 3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。



jdk 提供了快捷创建线程池的方式

1. `Executors` 类下提供了定长/延时/单一等线程池,但由于上线使用系统资源,一般不建议使用

2. 手动创建`ThreadPoolExecutor`对象

   其核心参数:

   ```java
   /**
   * 
   corePoolSize – 要保留在池中的线​​程数，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut
   maximumPoolSize – 池中允许的最大线程数
   keepAliveTime – 当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间。
   unit – keepAliveTime参数的时间单位
   workQueue – 用于在执行任务之前保存任务的队列。 这个队列将只保存execute方法提交的Runnable任务
   */
   public ThreadPoolExecutor(int corePoolSize,
                                 int maximumPoolSize,
                                 long keepAliveTime,
                                 TimeUnit unit,
                                 BlockingQueue<Runnable> workQueue) {
           this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                Executors.defaultThreadFactory(), defaultHandler);
       }
   ```

   其执行流程

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191109015558158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhbW9rZWxpc2lqaWFuODY2,size_16,color_FFFFFF,t_70)

[为什么一般不建议使用Executors创建线程池？_damokelisijian866的博客-CSDN博客](https://blog.csdn.net/damokelisijian866/article/details/102982390)



















[Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)