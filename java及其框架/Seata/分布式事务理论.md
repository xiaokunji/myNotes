[toc]



# 前言

## 一图解读分布式事务

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210710220330858.png)

### 名词解释

- **事务**：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。
- **本地事务**：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。
- **全局事务**：当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。
- **TX协议**：应用或者应用服务器与事务管理器的接口。
- **XA协议**：全局事务管理器与资源管理器的接口。XA是由X/Open组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了XA接口。XA接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。之所以需要XA是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。由全局事务管理器管理和协调的事务可以跨越多个资源和进程。全局事务管理器一般使用XA二阶段协议与数据库进行交互。
- **AP**：应用程序，可以理解为使用DTP（Data Tools Platform）的程序。
- **RM**：资源管理器，这里可以是一个DBMS或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。资源管理器负责控制和管理实际的资源。
- **TM**：事务管理器，负责协调和管理事务，提供给AP编程接口以及管理资源管理器。事务管理器控制着全局事务，管理事务的生命周期，并且协调资源。
- **两阶段提交协议**：XA用于在全局事务中协调多个资源的机制。TM和RM之间采取两阶段提交的方案来解决一致性问题。两节点提交需要一个协调者（TM）来掌控所有参与者（RM）节点的操作结果并且指引这些节点是否需要最终提交。两阶段提交的局限在于协议成本，准备阶段的持久成本，全局事务状态的持久成本，潜在故障点多带来的脆弱性，准备后，提交前的故障引发一系列隔离与恢复难题。
- **BASE理论**：BA指的是基本业务可用性，支持分区失败，S表示柔性状态，也就是允许短时间内不同步，E表示最终一致性，数据最终是一致的，但是实时是不一致的。原子性和持久性必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性和隔离性的要求。
- **CAP定理**：对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。C表示一致性，也就是所有用户看到的数据是一样的。A表示可用性，是指总能找到一个可用的数据副本。P表示分区容错性，能够容忍网络中断等故障。



## CAP定理

CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：

- 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)
- 可用性(Availability) ： 每个操作都必须以可预期的响应结束
- 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用，操作依然可以完成

具体地讲在分布式系统中，一个Web应用至多只能同时支持上面的两个属性。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020110223095013.jpg)

### CAP 权衡

> 通过 CAP 理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？

对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9，即保证 P 和 A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。

对于涉及到钱财这样不能有一丝让步的场景，C 必须保证。网络发生故障宁可停止服务，这是保证 CA，舍弃 P。貌似这几年国内银行业发生了不下 10 起事故，但影响面不大，报道也不多，广大群众知道的少。还有一种是保证 CP，舍弃 A。例如网络故障是只读不写。





## BASE定理

> CAP是分布式系统设计理论，BASE是CAP理论中AP方案的延伸，对于C我们采用的方式和策略就是保证最终一致性；

eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（StrongConsistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE基于CAP定理演化而来，核心思想是即时无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。



# 分布式事务分类

### 刚性事务

刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务。

原则：刚性事务满足足CAP的CP理论

> 刚性事务指的是，要使分布式事务，达到像本地式事务一样，具备数据强一致性，从CAP来看，就是说，要达到CP状态。

刚性事务：XA 协议（2PC、JTA、JTS）、3PC，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。



### 柔性事务

柔性事务指的是，不要求强一致性，而是要求最终一致性，允许有中间状态，也就是Base理论，换句话说，就是AP状态。

> 与刚性事务相比，柔性事务的特点为：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。

柔性事务分为：

- 补偿型
- 异步确保型
- 最大努力通知型。

柔型事务：TCC/FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）



# 刚性事务：XA

X/Open **DTP(Distributed Transaction Process)** 是一个分布式事务模型。这个模型主要使用了两段提交(2PC - Two-Phase-Commit)来保证分布式事务的完整性。

在X/Open **DTP(Distributed Transaction Process)**模型里面，有三个角色：

 AP: Application，应用程序。也就是业务层。哪些操作属于一个事务，就是AP定义的。

 TM: Transaction Manager，事务管理器。接收AP的事务请求，对全局事务进行管理，管理事务分支状态，协调RM的处理，通知RM哪些操作属于哪些全局事务以及事务分支等等。这个也是整个事务调度模型的核心部分。

 RM：Resource Manager，资源管理器。一般是数据库，也可以是其他的资源管理器，如消息队列(如JMS数据源)，文件系统等。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210709140731779.png)

> XA之所以需要引入事务管理器是因为，在分布式系统中，从理论上讲（参考Fischer等的论文），两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源（如数据库或JMS队列）



## XA规范

XA规范(XA Specification) 是X/OPEN 提出的分布式事务处理规范。XA则规范了TM与RM之间的通信接口，在TM与多个RM之间形成一个双向通信桥梁，从而在多个数据库资源下保证ACID四个特性。目前知名的数据库，如Oracle, DB2,mysql等，都是实现了XA接口的，都可以作为RM。



## XA协议的实现

### 2PC/3PC协议

两阶段提交（2PC）协议是XA规范定义的 数据一致性协议。

三阶段提交（3PC）协议对 2PC协议的一种扩展。

### Seata

Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式

### Seata AT 模式

Seata AT 模式是增强型2pc模式。

AT 模式： 两阶段提交协议的演变，没有一直锁表

- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源
- 二阶段：提交异步化，非常快速地完成。或回滚通过一阶段的回滚日志进行反向补偿



## XA的主要限制

- 必须要拿到所有数据源，而且数据源还要支持XA协议。目前**MySQL中只有InnoDB存储引擎支持XA协议。**
- 性能比较差，要把所有涉及到的数据都要锁定，是强一致性的，会产生长事务。





## 2PC（标准XA模型）

2PC即Two-Phase Commit，二阶段提交。

### 2PC节点角色

二阶段提交协议将节点分为：

- 协调者角色(事务管理器Coordinator)
- 参与者角色（资源管理器Participant）

2PC角色中，事务管理器的角色，负责协调多个数据库（资源管理器）的事务，

协调者角色(事务管理器Coordinator)，负责向参与者发送指令，收集参与者反馈，做出提交或者回滚决策

参与者角色（资源管理器Participant），接收协调者的指令执行事务操作，向协调者反馈操作结果，并继续执行协调者发送的最终指



### 详解：二个阶段

广泛应用在数据库领域，为了使得基于分布式架构的所有节点可以在进行事务处理时能够保持原子性和一致性。

顾名思义，2PC分为两个阶段处理，

- 阶段一：提交事务请求、
- 阶段二：执行事务提交，或者执行中断事务;

如果阶段一超时或者出现异常，2PC的阶段二为：执行中断事务

> 说明：绝大部分关系型数据库，都是基于2PC完成分布式的事务处理。

#### 阶段一：提交事务请求

1. 事务询问。协调者向所有参与者发送事务内容，询问是否可以执行提交操作，并开始等待各参与者进行响应；
2. 执行事务。各参与者节点，执行事务操作，并将Undo和Redo操作计入本机事务日志；
3. 各参与者向协调者反馈事务问询的响应。成功执行返回Yes，否则返回No。

#### 阶段二：提交或者中断事务

这一阶段包含两种情形：

- 执行事务提交，
- 执行中断事务

协调者在阶段二决定是否最终执行事务提交操作。

- 所有参与者reply Yes，那么执行事务提交。
- 当存在某一参与者向协调者发送No响应，或者等待超时。协调者只要无法收到所有参与者的Yes响应，就会中断事务。

##### 执行事务提交

所有参与者reply Yes，那么执行事务提交。

1. 发送提交请求。协调者向所有参与者发送Commit请求；
2. 事务提交。参与者收到Commit请求后，会**正式执行事务提交操作**，并在完成提交操作之后，释放在整个事务执行期间占用的资源；
3. 反馈事务提交结果。参与者在完成事务提交后，写协调者发送Ack消息确认；
4. 完成事务。协调者在收到所有参与者的Ack后，完成事务。

![事务提交示意图](https://img2018.cnblogs.com/blog/692462/201904/692462-20190407131001597-1193625164.png)



#####  执行事务中断

事情总会出现意外，当存在某一参与者向协调者发送No响应，或者等待超时。协调者只要无法收到所有参与者的Yes响应，就会中断事务。

1. 发送回滚请求。协调者向所有参与者发送Rollback请求；
2. 回滚。参与者收到请求后，利用本机Undo信息，执行Rollback操作。并在回滚结束后释放该事务所占用的系统资源；
3. 反馈回滚结果。参与者在完成回滚操作后，向协调者发送Ack消息；
4. 中断事务。协调者收到所有参与者的回滚Ack消息后，完成事务中断。

![事务中断示意图](https://img2018.cnblogs.com/blog/692462/201904/692462-20190407131017854-1201369651.png)





### 2PC二阶段提交的特点

2PC 方案比较适合单体应用里，跨多个库的分布式事务，而且因为**严重依赖于数据库层面来搞定复杂的事务**，效率很低



#### 2PC具有明显的优缺点：

**优点:**

- 主要体现在实现原理简单；

**缺点比较多：**

1. 同步阻塞导致性能问题

   执行过程中，所有参与节点都是事务阻塞型的。所有participant 都处于阻塞状态，各个participant 都在等待其他参与者响应，无法进行其他操作。

   所有分支的资源锁定时间，由最长的分支事务决定。

   另外当参与者锁定公共资源时，处于事务之外的其他第三方访问者，也不得不处于阻塞状态。

2. 单点故障导致高可用（HA）问题：

   协调者是个单点，一旦出现问题，各个participant 将无法释放事务资源，也无法完成事务操作；

   并且，由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。

   尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。

3. 丢失消息导致的数据不一致问题：

   如果协调者向所有参与者发送Commit请求后，发生局部网络异常,或者协调者在尚未给全部的participant发送完Commit请求即出现崩溃，最终导致只有部分participant收到、执行请求。部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

4. 过于保守：

   二阶段提交协议没有设计较为完善的容错机制，**任意一个节点的失败都会导致整个事务的失败**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d2010acd44ad413e8cd268691e840c24.png)



## 3PC

针对2PC的缺点，研究者提出了3PC，即Three-Phase Commit。

作为2PC的改进版，3PC将原有的两阶段过程，重新划分为CanCommit、PreCommit和do Commit三个阶段。

3PC 协议将 2PC 协议的准备阶段一分为二，从而形成了三个阶段：

![在这里插入图片描述](https://img-blog.csdnimg.cn/59117e6280d74adf85b05b9b63eda9de.png)



### 详解：三个阶段

所谓的三个阶段分别是：**询问，然后再锁资源，最后真正提交**。

- 第一阶段：CanCommit
- 第二阶段：PreCommit
- 第三阶段：Do Commit

![三阶段提交示意图](https://img2018.cnblogs.com/blog/692462/201904/692462-20190407142856081-1418301502.png)



#### 阶段一：CanCommit

1. 事务询问。协调者向所有参与者发送包含事务内容的canCommit的请求，询问是否可以执行事务提交，并等待应答；
2. 各参与者反馈事务询问。正常情况下，如果参与者认为可以顺利执行事务，则返回Yes，否则返回No。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ff3e391189654c27877a4ef4bede65c1.png)



#### 阶段二：PreCommit

在本阶段，协调者会根据上一阶段的反馈情况来决定是否可以执行事务的PreCommit操作。有以下两种可能：

- 执行事务预提交
- 中断事务

##### 执行事务预提交

1. 发送预提交请求。协调者向所有节点发出PreCommit请求，并进入prepared阶段；
2. 事务预提交。参与者收到PreCommit请求后，会**开始事务操作**，并将Undo和Redo日志写入本机事务日志；
3. 各参与者成功执行事务操作，同时将反馈以Ack响应形式发送给协调者，同事等待最终的Commit或Abort指令。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5ed9e070b1a94c5395d0f146afcf25d5.png)



##### 中断事务

如果任意一个参与者向协调者发送No响应，或者等待超时，协调者在没有得到所有参与者响应时，即可以中断事务。

中断事务的操作为：

1. 发送中断请求。 协调者向所有参与者发送Abort请求；
2. 中断事务。无论是participant 收到协调者的Abort请求，还是participant 等待协调者请求过程中出现超时，参与者都会中断事务；

coordinator发送Abort的两个场景

场景1： 任意一个参与者向协调者发送No响应

场景2： 协调者在没有得到所有参与者响应时

![在这里插入图片描述](https://img-blog.csdnimg.cn/5406d13600d94f6f9025d32931365c8d.png)



#### 阶段三：doCommit

在这个阶段，会真正的进行事务提交，同样存在两种可能。

- 执行提交
- 回滚事务

##### 执行提交

1. coordinator发送提交请求。假如coordinator协调者收到了所有参与者的Ack响应，那么将从预提交转换到提交状态，并向所有参与者，发送doCommit请求；
2. 事务提交。参与者收到doCommit请求后，会正式执行事务提交操作，并在完成提交操作后释放占用资源；
3. 反馈事务提交结果。参与者将在完成事务提交后，向协调者发送Ack消息；
4. 完成事务。协调者接收到所有参与者的Ack消息后，完成事务。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d72e14442ad842349c5c283f83f5dac1.png)

##### 回滚事务

在该阶段，假设正常状态的协调者接收到任一个参与者发送的No响应，或在超时时间内，仍旧没收到反馈消息，就会回滚事务：

1. 发送中断请求。协调者向所有的参与者发送rollback请求；
2. 事务回滚。参与者收到rollback请求后，会利用阶段二中的Undo消息执行事务回滚，并在完成回滚后释放占用资源；
3. 反馈事务回滚结果。参与者在完成回滚后向协调者发送Ack消息；
4. 回滚事务。协调者接收到所有参与者反馈的Ack消息后，完成事务回滚。

![在这里插入图片描述](https://img-blog.csdnimg.cn/40709d2418b849fb94b08627247feafa.png)





## 2PC和3PC的区别：

三阶段提交协议在协调者和参与者中都引入 **超时机制**，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。

三阶段提交的三个阶段分别为：can_commit，pre_commit，do_commit。

![img](https://img-blog.csdnimg.cn/20191210222510777.png)

在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rollback请求时，会在等待超时之后，继续进行事务的提交。

其实这个应该是基于概率来决定的，

当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，什么场景会产生PreCommit请求呢？

协调者产生PreCommit请求的前提条件比较严格：是在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。

> 所以，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了

一句话概括就是：

**当进入第三阶段时，由于网络超时/网络分区等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大**。



#### 3PC主要解决的单点故障问题：

相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，

**因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态**。

由于在docommit阶段，participant参与者如果超时，能自己决定提交本地事务，所以，3pc没有2pc那么**保守**或者说**悲观**，或者说3pc更加的**乐观**。



#### 3PC主要没有解决的数据一致性问题：

**但是这种机制，还是有数据一致性问题，或者说，没有彻底解决数据一致性问题。**

‘因为，由于网络原因，协调者发送的rollback命令没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。

这样就和其他接到rollback命令并执行回滚的参与者之间存在数据不一致的情况。



> #### "3PC相对于2PC而言到底优化了什么地方呢?"
>
> 相比较2PC而言，3PC对于**协调者（Coordinator）和参与者（Participant）都设置了超时时间**，而2PC只有协调者才拥有超时机制。
>
> 这解决了一个什么问题呢？
>
> 这个优化点，主要是避免了Participant 参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，
>
> 因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。
>
> 而这种机制也侧面降低了整个事务的阻塞时间和范围。
>
> 另外，通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较于2PC而言，**多设置了一个缓冲阶段**保证了在最后提交阶段之前各参与节点的状态是一致的。
>
> 以上就是3PC相对于2PC的一个提高（相对缓解了2PC中的前两个问题），但是3PC依然没有完全解决数据不一致的问题。
>
> 假如在 DoCommit 过程，参与者A无法接收协调者的通信，那么参与者A会自动提交，但是提交失败了，其他参与者成功了，此时数据就会不一致。









[分布式事务（ 图解 + 秒懂 + 史上最全 ） - 疯狂创客圈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/crazymakercircle/p/13917517.html#autoid-h2-4-0-0)











