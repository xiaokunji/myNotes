[TOC]
# 一 @Autowired

- 通过 @Autowired 的使用来消除 set ，get方法
>注:区别于Lombok,lombok是生成set和get方法,你能直接使用 ;

@Autowired 是用来注值的,spring注值本质上是用了set方法来找到对象并初始化的,在这个注解没出来前,需要写get,set方法
- 通过(1),可以看到,@Autowired 本质上是用来初始化对象的,(源城时好像是用来初始化实体类,捷顺用来初始化Dao层对象)

@Autowired默认按类型装配
>注:捷顺用来初始化Dao层对象,关键是怎么和Mapper连接呢,有两种方案: 
>-   在Dao层接口类上 写 @Mapper 注解,表示这个接口要对接mapper文件
>- 在application.xml中 添加配置:
```xml
<!-- 自动扫描了所有的XxxxMapper.java，这样就不用一个一个手动配置Mpper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.jieshun.jht.integral.dao" />
</bean>
```
> 来自 <http://www.cnblogs.com/zghull/archive/2012/06/27/2565480.html> 


# 二 @Resource

这个是用来初始化对象的,这和@Autowired注解不一样,
- @Autowired默认按类型装配 ,   
- @Resource按名称装配,

这是使用注解是要自己写名称的,捷顺在Controller里用初始化对象,使用这个注解,在接口实现类(impl)上使用注解 @Service("mebershipService")来表示这个类要放入IOC中,并指定名字,然后使用这个指定的名字就能获得对象,
>如果没有指定名字就会按类型装配

> 来自 <http://www.cnblogs.com/zghull/archive/2012/06/27/2565480.html> 


# 三 @Service

当你需要定义某个类为一个bean，则在这个类的类名前一行使用@Service("XXX"),就相当于讲这个类定义为一个bean，bean名称为XXX;   

会配合@Resource来使用

> 来自 <http://www.cnblogs.com/Struts-pring/p/4951661.html> 

​	

# 四 @Async

**用法:** 在方法上或者类上标注, 这样调用方法时就会异步执行,  它需要搭配 `@EnableAsync`注解使用

它还有一个value值,表示指定使用哪个线程池,不指定就用叫'taskExecutor'的线程池, 连默认线程池都没有就注解自己的线程池(有内存泄露风险,而且不重用线程)

**原理:**  Spring容器启动初始化bean时，判断类中是否使用了@Async注解，创建切入点和切入点处理器，根据切入点创建代理，在调用@Async注解标注的方法时，会调用代理，执行切入点处理器invoke方法，将方法的执行提交给线程池，实现异步执行。

> 需要注意的一个错误用法是，如果A类的a方法(没有标注@Async)调用它自己的b方法(标注@Async)是不会异步执行的，因为从a方法进入调用的都是它本身，不会进入代理。(称为本地调用)
>
> `mode=AdviceMode.ASPECTJ` 指定切面模式就可以生效

[Spring @Async之四：Aysnc的异步执行的线程池实现原理 - duanxz - 博客园 (cnblogs.com)](https://www.cnblogs.com/duanxz/p/9438757.html)

[Spring @Async 注解的使用以及原理（一）_灵颖桥人的博客-CSDN博客_@async注解](https://blog.csdn.net/qq_22076345/article/details/82194482)