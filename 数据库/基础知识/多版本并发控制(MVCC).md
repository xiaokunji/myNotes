[toc]
# 1. 什么是多版本并发控制（ MVCC ）
MySQL 的大多数事务型存储引擎基于提升并发性能的考虑，一般都实现了多版本并发控制（ MVCC ）。MVCC 是行级锁的一个变种，但实际上实现机制有所不同，避免了加锁的操作，因此有了更低的开销和更高的性能。

MVCC 的实现，是通过保持数据在某个时间点的快照来实现的，不管事务的执行时间有多久，MVCC 保障了每一个事务内看到的数据是一致的，而根据事务开始时间，不同事务看到同一张表，同一份数据可能是不同的。 MVCC的实现，是通过保存数据在某个时间点的快照来实现的。    
**需要注意的是，MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，其他两个级别都和MVCC“不兼容”。因为READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行都加锁。**
> 保存这两个额外的系统版本号，使大多数的读操作都不用加锁，这样的设计使得读数据操作很简单，性能很好，并且只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多额外的检查工作和维护工作。

不同存储引擎对 MVCC 的实现机制不尽相同，因为 MVCC 并没有一个统一的标准，下面以 InnoDB 为例，简要介绍 MVCC 的实现原理。
> 注: 多版本并发控制不支持myisam存储引擎。估计是因为myism是锁整个表,做不到版本控制


# 2. InnoDB 中的 MVCC
InnoDB 中的 MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个特殊的列一个保存了行的创建时间，一个保存了行的删除时间。当然这里存储的并不是真实的时间，实际上存储的是版本号（ system version number ）。每次开启一个新的事务，系统版本号会开始递增并分配给当前的事务，用于与数据的版本号进行比较。简要介绍下 InnoDB 是如何操作的：

1. SELECT：在 InnoDB 中，SELECT 操作有两个额外的条件：   
    - 只查找行的创建版本号小于或等于当前事务版本号的数据。这样可以保证事务读取的数据要么是在事务开始之前就已经存在，要么是事务本身插入或者修改过的。
    - 行的删除版本号要么未定义，要么大于当前事务的版本号。这样是为了确保事务读取的数据在事务开始之前未被删除。
2. INSERT：InnoDB 为每行新增数据设置了当前事务的版本号作为创建版本号，删除版本号留空。
3. DELETE：InnoDB 为每行删除的数据设置了当前事务的版本号作为删除版本号。
4. UPDATE：InnoDB 额外插入一条新的记录，将当前事务版本号作为新记录的创建版本号，同时保存当前事务版本号到原来的数据中的删除版本号。

> 在 InnoDB 中，MVCC 只在 READ COMMITTED 和 REPEATABLE READ 这两个隔离级别下工作。其他的隔离级别和 MVCC 并不兼容，READ UNCOMMITTED 总是读取最新的数据，而 SERIALIZABLE 则会对所有读取的行都进行加锁操作。

> 来自: https://blog.csdn.net/qq_35499060/article/details/83590723