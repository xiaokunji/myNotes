[toc]
# 1. sql优化
1. 对查询进行优化，**应尽量避免全表扫描**，首先应考虑在 where 及 order by 涉及的列上建立索引。 

2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：    

```
select id from t where num is null 
```
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    

```
select id from t where num=0   
```

3. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。    
    
4. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描(如果or的每个条件都有索引,则or会走索引)，如：    
`select id from t where num=10 or num=20   `    
可以这样查询：       
```
select id from t where num=10    
union all    
select id from t where num=20    
```
    
5. in 和 not in 也要慎用，否则会导致全表扫描，如：    
`select id from t where num in(1,2,3)    `   
对于连续的数值，能用 between 就不要用 in 了：    
`select id from t where num between 1 and 3   ` 
    
6. 下面的查询也将导致全表扫描：    
`select id from t where name like '%abc%'    `
    
7. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：    
`select id from t where num/2=100  `    
应改为:    
`select id from t where num=100*2   ` 
    
8. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：    
`select id from t where substring(name,1,3)='abc'--name以abc开头的id `  
应改为:    
`select id from t where name like 'abc%'    `
    
9. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。    
    
10. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。    
    
11. 不要写一些没有意义的查询，如需要生成一个空表结构：    
`select col1,col2 into #t from t where 1=0    `  
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：      
`create table #t(...)    `
    
12. 很多时候用 exists 代替 in 是一个好的选择：    
`select num from a where num in(select num from b)    `   
用下面的语句替换：      
`select num from a where exists(select 1 from b where num=a.num) `

> https://blog.csdn.net/qq_38789941/article/details/83744271

# 2. 数据库优化
1. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，++当索引列有大量数据重复时++，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。    
    
2. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，++但同时也降低了 insert 及 update 的效率，++
因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。    
一个表的索引数最好**不要超过6个**，若太多则应考虑一些不常使用到的列上建的索引是否有必要。    
    
3. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。    
这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。    
    
4. 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，    
其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。    
    
5. 任何地方都不要使用 
 `select * from t ，用具体的字段列表代替“*”，`不要返回用不到的任何字段。    
    
6. 避免频繁创建和删除临时表，以减少系统表资源的消耗。

7. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。    
    
8. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，    
以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

9. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。    
    
10. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。    
    
11. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

12. 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。
在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

13. 尽量避免大事务操作，提高系统并发能力。

14. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。

> https://blog.csdn.net/qq_38789941/article/details/83744271

# 3. 悲观锁和乐观锁
1. 乐观锁：  
  乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时（更新操作），想法很乐观，认为这次的操作不会导致冲突，在操作数据室，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。  
通常是这样实现的：在表中的数据进行操作时（更新），会给数据表中加一个版本（version）字段，每操作一次将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段，如果涛对那条记录进行操作（更新），则先判断此刻version的值是否与刚刚查出来的version的值相等，如果相等，则说明这段期间，没有其他程序对齐进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的verison的值不相等，则说明这段期间已经有其他程序对齐进行操作了，则不进行更新操作。

> 例子：
> 1.查询出商品信息  
> select * from goods where id=#{id}  
> 2.根据商品信息生成订单  
> 3.修改商品status为2  
> update goods set status = 2,version = version +1 where id=#{id}

2. 悲观锁：  
 与乐观所相对应的就是悲观锁。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这单跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁室友数据库自己实现的，要用的时候，我们直接调用数据库的相关语句就可以 了。

由悲观锁涉及到的两个锁概念：共享锁与排他锁。
# 4. 共享锁与排他锁
1. 共享锁：  
 共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。相当于对于同一把门，它拥有多个钥匙一样。对于悲观锁，一般数据库已经实现了，共享锁也属于悲观锁的一种，共享锁，也叫读锁。就是我们对数据进行读取操作的时候，其实是不会改变数据的值的。  
所以我们可以给数据库增加读锁，获得读锁的事务就可以读取数据了。当数据库已经被别人增加了读锁的时候，其他新来的事务也可以读数据，但是不能写。  
也就是说，如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。  
用法
在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁。
```
SELECT ... LOCK IN SHARE MODE;
```
当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。
 
2. 排它锁：  
 排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。 排他锁，也叫写锁。就是我们对数据进行写操作的时候，要先获得写锁，获得写锁的事务既可以写数据也可以读数据。但是，如果数据库已经被别人增加了排他写锁，那么后面的事务是无法在获得该数据库的任何锁的。  
也就是说，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。  
用法
在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁
```
SELECT ... FOR UPDATE;
```

当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。

>来自:  https://www.cnblogs.com/fanghl/p/11316540.html

# 5. 索引的目的是什么？

1. 快速访问数据表中的特定信息，提高检索速度
2. 创建唯一性索引，保证数据库表中每一行数据的唯一性。
3. 加速表和表之间的连接
4. 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间

# 6. 索引对数据库系统的负面影响是什么？
1. 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；
2. 索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；
3. 当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 

# 7. 为数据表建立索引的原则有哪些？
1. 在最频繁使用的、用以缩小查询范围的字段上建立索引。
2. 在频繁使用的、需要排序的字段上建立索引
3. 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。
3. 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等

> 原文链接：https://blog.csdn.net/qq_34988624/article/details/85838850 

