[toc]

# 主从复制
**复制过程**:
1. 从服务器连接主服务器，发送SYNC（同步）命令；
2. 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；
3. 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；
4. 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；
5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；
6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（从服务器初始化完成）
7. 主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）

**优点**:

1. <u>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成</u>
2. Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。
3. Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
4. Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据

**缺点**
1. Redis不具备自动容错和恢复功能，++主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。++
2. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
3. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

链接：https://www.jianshu.com/p/7967f95655b2
> 主从复制是基础,后面的哨兵和Cluster都是基于这种方式,但是这种方式太垃圾了,master死了就不能写操作了,所以一般会用后面两种
使用主从复制很简单,在配置文件中指定master/slave,并设置密码(必须使用)

# 哨兵模式
哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。
1. 监控主服务器和从服务器是否正常运行。
2. 主服务器出现故障时自动将从服务器转换为主服务器。
> 弥补了主从模式下的master死亡的情况

哨兵是集群,有主节点和从节点,也会产生选举(基于Raft算法(但不一样),和kafka一样),会选举哨兵主节点,redis的master,( 每个redis的bin下都有一个哨兵启动文件),在sentinel模式下,客户端就不用直接连接Redis，而是连接sentinel的ip和port

> 哨兵是一个独立的进程，作为进程，它会独立运行
>
> **每个哨兵通过主节点去发现其他从节点和其他哨兵的**

![image](https://upload-images.jianshu.io/upload_images/11320039-3f40b17c0412116c.png?imageMogr2/auto-orient/strip|imageView2/2/w/747/format/webp)

**工作方式**

* 每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 
* 如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为**主观下线**。 
* 如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率(发送info命令)确认master的确进入了主观下线状态
* 当有足够数量(`quorum`)的sentinel在30s（`down-after-milliseconds`）内确认master的确进入了主观下线状态， 则master会被标记为**客观下线** 
* 在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 
* 当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 
* 若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除； 若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除

>redis自带哨兵,不需要借助第三方,只需要简单配置即可 ,生产环境建议让redis Sentinel部署到不同的物理机上。  
>
>原文链接：https://blog.csdn.net/miss1181248983/article/details/90056960

>哨兵可以解决大量读的问题,如果有大量写,哨兵也扛不住,这需要Twemproxy,做数据的分片处理,再配合 Lvs 和 Keepalived 解决Twemproxy的单点故障   
>
>https://www.jianshu.com/p/84dbb25cc8dc



**哨兵与各节点**

> 哨兵和master通过配置文件直连

1. Sentinel 自动发现 Slave
   	- 每 10 秒 Sentinel 向 master 节点发送 INFO 命令后获取到所有 slave 的信息
      	- Sentinel 与 slave 建立命令连接和订阅连接

2. sentinel 自动发现机制
   - Sentinel 利用 pub/sub（发布/订阅）机制，订阅了每个 master 和 slave 数据节点的 `__sentinel__:hello` 频道，去自动发现其它也监控了统一 master 的 sentinel 节点
   - Sentinel 向每 1s 向 `__sentinel__:hello` 中发送一条消息，包含了其当前维护的最新的 master 配置。如果某个sentinel发现自己的配置版本低于接收到的配置版本，则会用新的配置更新自己的 master 配置
   - 与发现的 Sentinel 之间相互建立命令连接，之后会通过这个命令连接来交换对于 master 数据节点的看法

> 建立两个异步网络连接：
>
> 1. 命令连接：用于向 Redis master 数据节点发送命令，例如通过 INFO 命令了解：
>    - master 本身运行信息，用于更新本地的 master 字典（Redis Hash 的实现中用到字典使用的的也是这个数据结构）
>    - slaves 信息（角色、IP、Port、连接状态、优先级、复制偏移量），用于更新本地的 slave 字典
>
> 2. 订阅连接：订阅 `__sentinel__:hello` 频道，用于发现其他 Sentinel，频道中信息包括：
>    - Sentinel 自身信息（IP、Port、RunID、Epoch）
>    - 监视的 Master 节点的信息（Name、IP、Port、Epoch）
>
> [Redis 哨兵模式(Sentinel) 原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/201534164)



**选举过程**

1. 先选举出sentinel中的leader

   > 用的过半选举那套,最终决定leader时是 leader最低票数( `quorum`和`Sentinel`节点数/2+1的最大值), 所以推荐sentinel要部署奇数台

2. 然后又sentinel的leader选举slave为master

   - 过滤故障的节点
   - 选择优先级slave-priority最大的从节点作为主节点，如不存在则继续
   - 选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续
   - 选择runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点

[redis哨兵模式选举机制_LiaoHongHB的博客-CSDN博客_redis哨兵模式选举机制](https://blog.csdn.net/LiaoHongHB/article/details/109092165)



# Cluster模式
redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。(取数据的时候直接找到对应地址去取)

Redis-Cluster采用无中心结构,它的特点如下

1.  所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
2. 节点的fail是通过集群中超过半数的节点检测失效时才生效。
3.  客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

**工作方式**   

在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。<u>当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果</u>，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，<u>去找到对应的插槽所对应的节点</u>，然后直接自动跳转到这个对应的节点上进行存取操作。

为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了

>启用集群模式也是通过配置即可,这里只是简述,分布数据以及后续内容远不止这些
>
>链接：https://www.jianshu.com/p/7967f95655b2    
>
>https://blog.csdn.net/miss1181248983/article/details/90056960    
>
>https://www.cnblogs.com/williamjie/p/11132211.html

