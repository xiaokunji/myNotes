[toc]
# 常用参数说明

配置项 | 说明
---|---
daemonize no | Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）
pidfile /var/run/redis.pid | 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定
port 6379 | 指定 Redis 监听端口，默认端口为 6379
bind 127.0.0.1 | 绑定的主机地址,默认只允许本地访问,将此配置删除,则允许外网访问(但是不建议,因为redis处理快,可能被暴力破解,而且以前也出现过redis漏洞)
logfile stdout | 日志记录方式，默认为标准输出，也可以写文件路径,如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null
requirepass password | 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭
> https://www.runoob.com/redis/redis-conf.html


# 数据类型
Redis支持五种数据类型：
- **string**（字符串），
- **hash**（哈希），
- **list**（列表），
- **set**（集合）
- **zset**(sorted set：有序集合)。
## String
string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。   
string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。

```
// 基本命令
SET runoob "菜鸟教程"
GET runoob
```


## Hash
Redis hash 是一个键值(key=>value)对集合。

Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。
每个 hash 可以存储  
```math
2^{32}-1
```
键值对（40多亿）。
> 可以理解为vaule是一个map,里面存很多k-v

```
HMSET runoob field1 "Hello" field2 "World"
HGET runoob field1
```

## List
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
> - 比如可以通过lrange命令，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走   
>- 比如可以搞个简单的消息队列，从list头怼进去，从list尾巴那里弄出来

```
lpush runoob redis
lpush runoob mongodb
lrange runoob 0 10
```

## set
Redis 的 Set 是 string 类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 
```math
2^{32}-1
```
(4294967295,  每个集合可存储40多亿个成员)。如果有多台服务器产生的值需要放一起去重,就可以用set全局去重了

```
sadd runoob redis
sadd runoob mongodb
sadd runoob mongodb
smembers runoob
```

## zset
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。比如把分数换成时间戳,就可以按照时间来排序啦

zset的成员是唯一的,但分数(score)却可以重复。score可以是整数，也可以是浮点数，还可以是+inf表示无穷大，-inf表示负无穷大

```
zadd runoob 0 redis
zadd runoob 0 mongodb
zadd runoob 0 mongodb
zadd runoob 1 rabitmq
ZRANGEBYSCORE runoob 0 1000
ZRANGEBYSCORE runoob 0 +inf
```

## HyperLogLog (不算类型)
Redis 在 2.8.9 版本添加了 HyperLogLog 结构。用来计算集合数量,(基数数量,理解为去重后数量),数量值为估算,不是100%准确(这是因为它的(概率)算法),一般用来统计在线用户数,访问量等等  
感觉有set,HyperLogLog就鸡肋了,其实不然,HyperLogLog统计数量时要求内存很小,几乎是恒定的,但是set会随着集合增加而增大所需内存
```
PFADD runoobkey "redis"
PFADD runoobkey "mongodb"
PFCOUNT runoobkey
```

# 过期策略
如果假设你设置一个一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？
答案是：**定期删除+惰性删除**   
-   定期删除: 指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除.
-   惰性删除: 获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。 

所以并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下

很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。
如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？
答案是：走内存淘汰机制。

# 内存淘汰
最大内存的设置是通过设置maxmemory来完成的，格式为maxmemory bytes ,当目前使用的内存超过了设置的最大内存，就会进行内存释放
1.  noeviction：新写入操作会报错(不删除数据),也是**默认值**
2.  allkeys-lru：在键空间中，移除最近最少使用的key
3.  allkeys-random：在键空间中，随机移除某个key
4.  volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key
5.  volatile-random：在设置了过期时间的键空间中，随机移除某个key
6.  volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除

# 持久化
Redis的一种持久化方式叫**快照**（snapshotting，RDB）,另一种方式是**只追加文件**（append-only file,AOF）.**默认使用RDB方式**   
Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。
 <font color="#FF0000">++启动时优先从AOF文件中恢复数据++ </font>


如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。
> 链接：https://www.jianshu.com/p/65765dd10671

>AOF 文件的体积通常要大于 RDB 文件的体积。   
AOF的速度会慢于RDB方式 ,因为AOF默认是每秒同步一次

## RDB持久化
RDB持久化方式是通过快照(snapshotting)完成的，当符合一定条件时，redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当redis重启时，并且AOF持久化未开启时(默认不开启)，redis会读取RDB持久化生成的二进制文件(默认名称dump.rdb，可通过设置dbfilename修改)进行数据恢复，对于持久化信息可以用过命令“info Persistence”查看。

RDB生成快照可自动促发，也可以使用命令手动触发，以下是redis触发执行快照条件，后续会对每个条件详细说明：

1.  客户端执行命令save和bgsave会生成快照；
2.  根据配置文件save m n规则进行自动快照；
3.  主从复制时，从库全量复制同步主库数据，此时主库会执行bgsave命令进行快照；
4.  客户端执行数据库清空命令FLUSHALL时候，触发快照(清空快照)；
5.  客户端执行shutdown关闭redis时，触发快照(保存全部数据,以便下次启动恢复)；

> - 客户端执行save命令，该命令强制redis执行快照，这时候redis处于阻塞状态，不会响应任何其他客户端发来的请求，直到RDB快照文件执行完毕，所以请慎用。
>-  save m n规则说明：在指定的m秒内，redis中有n个键发生改变，则自动触发bgsave。该规则默认也在redis.conf中进行了配置，并且可组合使用(就是写多个)，满足其中一个规则，则触发bgsave

## AOF持久化
默认情况下，redis是关闭了AOF持久化，开启AOF通过配置appendonly为yes开启(配置文件).AOF实现本质是基于redis通讯协议，将命令以纯文本的方式写入到文件中。
>我们修改配置文件或者在命令行直接使用config set修改，在用config rewrite同步到配置文件。通过客户端修改好处是不用重启redis，AOF持久化直接生效。但不是所有的配置都可以这样,了解一下,还是老实改配置文件吧 

**AOF持久化过程**   
redisAOF持久化过程可分为以下阶段：
1.  追加写入   
　　redis将每一条写命令以redis通讯协议添加至缓冲区aof_buf,这样的好处在于在大量写请求情况下，采用缓冲区暂存一部分命令随后根据策略一次性写入磁盘，这样可以减少磁盘的I/O次数，提高性能。
2.  同步命令到硬盘
    当写命令写入aof_buf缓冲区后，redis会将缓冲区的命令写入到文件，redis提供了三种同步策略，由配置参数appendfsync决定，下面是每个策略所对应的含义：
-   appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
-   appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘(**默认值**)
-   appendfsync no      #让操作系统决定何时进行同步

3.  文件重写(bgrewriteaof)   
　　当开启的AOF时，随着时间推移，AOF文件会越来越大,当然redis也对AOF文件进行了优化，即触发AOF文件重写条件（后续会说明）时候，redis将使用bgrewriteaof对AOF文件进行重写。这样的好处在于减少AOF文件大小，同时有利于数据的恢复。
重写时候策略：
-   重复或无效的命令不写入文件
-   过期的数据不再写入文件
-   多条命令合并写入（当多个命令能合并一条命令时候会对其优化合并作为一个命令写入，例如`“RPUSH list1 a RPUSH list1 b" 合并为“RPUSH list1 a b” `）
> 重写触发条件    
>AOF文件触发条件可分为手动触发和自动触发：
> -   手动触发：客户端执行bgrewriteaof命令。
> -   自动触发：自动触发通过以下两个配置协作生效：
> - auto-aof-rewrite-min-size: AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。
> - auto-aof-rewrite-percentage：当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。　

## RDB-AOF混合持久化
Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble yes` 开启）。
> Redis 5.0 则默认开启

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头


> 链接：https://www.jianshu.com/p/65765dd10671
https://www.cnblogs.com/wdliu/p/9377278.html