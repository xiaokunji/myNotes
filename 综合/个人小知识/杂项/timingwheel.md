TimingWheel基本原理:

  众所周知寻常的定时器大概有两种，一种是开阻塞线程，另一种是开一个任务队列然后定期扫描。显而易见这两种方式的弊端很明显，前者对线程消耗过大，后者对时间消耗过大（很多未到时间的任务会被多次重复扫描消耗性能）

  为了解决以上两个问题就可以使用TimingWheel数据结构。

![img](https://img-blog.csdn.net/20180608163933512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNMWU4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 很明显时间轮算法是基于循环链表数据结构。那么他的工作原理具体是怎样的呢？

  能看到图中有个指针，我们假设指针没跳动一下需要10秒，然后现在我们有一个50秒后执行的任务A，由此推断在当前指针指向2的时候，任务A会被存放在槽格7中。当指针跳动到7后取出槽格中的任务队列，此时任务A将会被执行。但是当如果有100秒后的任务需要执行，依然超出了槽格数量是该怎么办呢？很简单，我们为任务实例添加一个属性“圈数”就可以解决。就是说每次装载任务时算出此任务需要指针转动几圈才能够被执行。



[来源](https://blog.csdn.net/EricLYN/article/details/80624521)